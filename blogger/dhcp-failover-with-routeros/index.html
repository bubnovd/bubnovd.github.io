<!doctype html><html lang=en><head><title>DHCP Failover with RouterOS :: Админская фамилия</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="DHCP сервер - одна из наиболее критичных служб сетевой инфраструктуры. Он обычно прост в настройке и не привлекает к себе внимание до того момента пока в сети не начинаются непонятные моменты: машины не получают адреса или получают, но совсем не те, которые хотел бы администратор. Вследствие чего сеть просто перестает работать.
В этой статье попробуем создать отказоустойчивый DHCP сервер на Mikrotik RouterOS.
Для понимания работы системы системы нужно сначала понять принцип работы самого протокола."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://bubnovd.net/blogger/dhcp-failover-with-routeros/><link rel=stylesheet href=https://bubnovd.net/assets/style.css><link rel=stylesheet href=https://bubnovd.net/assets/blue.css><link rel=apple-touch-icon href=https://bubnovd.net/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://bubnovd.net/img/favicon/blue.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="DHCP Failover with RouterOS"><meta property="og:description" content="DHCP сервер - одна из наиболее критичных служб сетевой инфраструктуры. Он обычно прост в настройке и не привлекает к себе внимание до того момента пока в сети не начинаются непонятные моменты: машины не получают адреса или получают, но совсем не те, которые хотел бы администратор. Вследствие чего сеть просто перестает работать.
В этой статье попробуем создать отказоустойчивый DHCP сервер на Mikrotik RouterOS.
Для понимания работы системы системы нужно сначала понять принцип работы самого протокола."><meta property="og:url" content="https://bubnovd.net/blogger/dhcp-failover-with-routeros/"><meta property="og:site_name" content="Админская фамилия"><meta property="og:image" content="https://bubnovd.net/img/favicon/blue.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2017-07-18 04:02:00 +0000 UTC"></head><body class=blue><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://bubnovd.net/><div class=logo>Terminal</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://bubnovd.net/blogger/dhcp-failover-with-routeros/>DHCP Failover with RouterOS</a></h1><div class=post-meta><span class=post-date>2017-07-18</span>
<span class=post-author>:: map[name:devi1 uri:https://www.blogger.com/profile/05777499482649623616]</span>
<span class=post-reading-time>:: 8 min read (1659 words)</span></div><span class=post-tags>#<a href=https://bubnovd.net/tags/dhcp/>DHCP</a>&nbsp;
#<a href=https://bubnovd.net/tags/routeros/>routeros</a>&nbsp;
#<a href=https://bubnovd.net/tags/delay-threshold/>delay-threshold</a>&nbsp;
#<a href=https://bubnovd.net/tags/mikrotik/>Mikrotik</a>&nbsp;
#<a href=https://bubnovd.net/tags/failover/>failover</a>&nbsp;</span><div class=post-content><div><p>DHCP сервер - одна из наиболее критичных служб сетевой инфраструктуры. Он обычно прост в настройке и не привлекает к себе внимание до того момента пока в сети не начинаются непонятные моменты: машины не получают адреса или получают, но совсем не те, которые хотел бы администратор. Вследствие чего сеть просто перестает работать.</p><p>В этой статье попробуем создать отказоустойчивый DHCP сервер на Mikrotik RouterOS.</p><p>Для понимания работы системы системы нужно сначала понять принцип работы самого протокола. Тем, кто и так это знает, следующий пункт можно не читать.</p><p>Принцип работы протокола DHCP</p><p>При включении хоста, его DHCP клиент производит broadcast рассылку DHCPDISCOVER на адрес 255.255.255.255, в которой указывает свой MAC адрес в качестве адреса отправителя. В ней хост пытается найти DHCP сервер в своем сегменте. Этот пакет долетит до всех хостов в сети.</p><p><img src=https://lh5.googleusercontent.com/FLQXFQ4smFlKp4wSlevig0hsrerw5L2tuhm9PTfMXVH-IzvJPOhnFZwe3bnnnv6_oACwLttU3Hjac8ZIqeU-KzKjjq0t6RTvbTjl8CvTkJ7d4FmBc70T0K0ZdMWZsL0Ogyw-06k4 alt></p><p>Здесь нас интересует поле Client MAC Address. Именно ему будет отвечать сервер.</p><p><img src=https://lh4.googleusercontent.com/C7LoJViNL1dB8hi_9s4TI1BQ8ENn2hDovEzt_8KPZlmAE-AU80OKOlNZvZIAwkVc_z_sglQKArzx5VOsy6SRIeZlB7YROODP-mh23Yn3F6h82uXk9nhNgGA9i8xVhp58wzXRwizC alt></p><p>Когда этот пакет долетает до DHCP сервера, тот отвечает на запрос пакетом DHCPOFFER, в котором сообщает свой IP адрес, предполагаемый адрес клиента и другие параметры, такие как адреса DNS серверов, NTP, WINS и другие.</p><p><img src=https://lh6.googleusercontent.com/DGU4rHi7rxu6aq7CmgAI4lzGfUeTIZBeXbsUTIfMImjyS2qz6wEuU1qRKhIg_qvGSJD4zfkBqJJ1BGQ8R8PGRbUFrrSOxZbxqBqOD1-H6Om7lh62_9EwSDTOh4WRlyiFVR1HJnNF alt></p><p>Важным параметром здесь является параметр Lease Time: это время в секундах, на которое сервер выдает клиенту адрес. По истечении этого времени клиент должен запросить аренду снова. Как это происходит рассмотрим чуть ниже.</p><p><img src=https://lh6.googleusercontent.com/5WPoG5iHXhViRGe-mAkgLJOj9ps46kCXrtv5dZqWbwaOx_mY4G8prFhQACA8sHxbr21Bla8dRm3AuCcpK4IBOn-fq0KQZsOL7DPtNUnCcH854uIzf3-macyWzK0iiGRuvPAORMz3 alt></p><p>Затем клиент обрабатывает OFFER и посылает на широковещательный адрес 255.255.255.255 DHCPREQUEST, где спрашивает разрешение у сервера использовать предложенный им (сервером) адрес и сообщает другим серверам о том, что выбран нужный сервер и адрес. Этот пакет долетит до всех хостов в сети.</p><p><img src=https://lh4.googleusercontent.com/J03-xD-gVzhwCbwYr0Y-HD56P6WqWK09Z0Qka8kJFeRPHXsI-jI2aEFcED2R_AlSxDXK2vdsYBxIF42QX4_0A8cCBufTI2PD4qkFiOt7PXscFEjRz_ObRNLD4fEfixjCoBd-1WDg alt></p><p>В поле Requested IP Address клиент запашивает IP адрес, который он хочет использовать.</p><p><img src=https://lh3.googleusercontent.com/khxjYfCdC5vqDPE671oKgQrcEjnp2hC3WOOqMeYnsmIVsnwB8Vti2THDS9ubgVzg4mdiOcyVoUaajqAowux-3kWWOmYCgNL3iEIk-eNHRdC20r63PmCIqQq7WWiBiUnqhbWTT6QW alt></p><p>В ответ сервер отвечает пакетом DHCPACK, в котором подтверждает использование выбранного адреса.</p><p><img src=https://lh4.googleusercontent.com/u_QQIwZtbcRNkzw4TG-FlN5ItsiMMS4E0I8aSaIDcEffTdMGWpBTgFpIq7Og-ehCC9-f--2VKDlMVJAyYueUpMkuo2_yHMffVHrp5cpAAxb7ha7KzhvX8k-cH2O7noo-m-t-O4m- alt></p><p>Этот пакет отсылается уже с IP адреса сервера на IP адрес клиента.</p><p><img src=https://lh6.googleusercontent.com/NTA4SrQH4Q-9sInK5by84eeYLgeGmRxp4UFvHYHAB3GJXnI6Vfac5DztkX9EK-i4nQWtHHbq1C1gL7ixzo1W2U670lOWZ-xWrE9SNiF6wTtSwuTH6NnNjMyzqnmcsr40pOY0p1ST alt></p><p>Весь процесс выглядит так:</p><p><img src=https://lh4.googleusercontent.com/FRRIxGH_CY_p_vnxHAbq_NJcl1CNiYS5k7z6aAnCE8sY_75cZkhhkaaS7BG1-aCo8BPtuwtHc4dE8PE6AVpTA-LsqQ3OfBdaRDpVXmbEbEx1_F6Ld9E1ekJSEOoWdPUjfb_lxmVm alt></p><p>По истечении половины Lease Time клиент отсылает серверу пакет DHCPREQUEST, в котором просит продлить время аренды на Lease Time, на что сервер должен ответить DHCPACK, если разрешает клиенту использовать запрошенный адрес. Или DHCPNACK, если не разрешает. Процесс повторяется через каждую половину Lease Time.</p><p>В случае, если сервер не подтвердит использование этого адреса, клиент ждет ещё половину Lease Time и начинает процесс самого начала: освобождает свой адрес и ищет DHCP сервер, с помощью пакета DHCPDISCOVER.</p><p><strong>Настройка отказоустойчивости DHCP в Mikrtoik</strong></p><p>О настройке DHCP сервера и клиента в Mikrotik RouterOS сказано немало. В том числе, в курсе <a href=http://www.bubnovd.net/2017/11/MTCNA.html>Mikrotik Certified Network Associate - MTCNA</a>. Здесь не будем рассматривать типичную настройку, а коснемся некоторых нюансов для обеспечения отказоустойчивости.</p><p>Чтобы обеспечить отказоустойчивость сервиса DHCP можно просто развернуть в одной сети несколько DHCP серверов. Тогда клиент будет получать адрес от того сервера, который первым ответит на DISCOVER. Но тут возникает проблема: несколько клиентов могут получить один и тот же адрес и никто из них не сможет нормально работать.</p><p>Выход напрашивается такой: раздавать адреса из разных пулов. К примеру, один сервер будет раздавать адреса из пула 192.168.0.0/25, а второй - из пула 192.168.0.128/25. Тогда мы покрываем работоспособность всей сети 192.168.0.0/24. Но что произойдет, если один из DHCP серверов откажется работать? Тогда работать будет лишь одна часть сети - 192.168.0.0/25 или 192.168.0.128/25. Полной отказоустойчивости не получим.</p><p>На помощь приходит параметр Delay Threshold. В <a href=https://wiki.mikrotik.com/wiki/Manual:IP/DHCP_Server#General>wiki Mikrotik</a> сказано:</p><p>Если поле secs в DHCP пакете меньше, чем параметр delay-threshold, то пакет игнорируется DHCP сервером. Если параметр установлен в none - все пакеты будут обрабатываться.</p><p>В пакетах DHCPREQUEST и DHCPDISCOVER есть поле Seconds, описывающее время, прошедшее с момента начала активности клиента.</p><p><img src=https://lh6.googleusercontent.com/LXrNEPHdW9C1DJs_2tN-oXfLcIM-yvH6rqqHNz6Qi8s-jBzXG6m3F-2YgP_vmaT_jZ1Qhp8tER93lRzRbzjXM3CylN2lqnXhM4vw9F1SpsvSDje3rs7oYpdmnsNJIYvq5YOdgAsR alt></p><p>Дело в том, что при отсутствии ответа от сервера, клиент не успокаивается на одном запросе. Он будет слать запросы к серверу с экспоненциальным ростом задержки, чтобы не зафлудить своими сообщениями сеть и при этом ещё пытаться получить DHCPACK или DHCPOFFER.</p><p>Так вот параметр delay-threshold проверяет поле seconds elapsed пакета DHCPREQUEST, и если количество секунд, указанное в этом поле меньше значения delay-threshold, то сервер просто игнорирует такие пакеты. А если больше, то отвечает на них.</p><p>Если установить у DHCP сервера delay-threshold=30, то клиент сможет получить DHCPOFFER, а следом за ним и свой адрес в DHCPACK, только по истечении 30 секунд после первого запроса.</p><p>Тут стоит заметить, что  в RouterOS 6.39.2, на которой я провожу эксперименты, delay-threshold влияет только на пакеты DHCPDISCOVER.</p><p>Значит, можно разместить в одной сети два абсолютно идентичных DHCP сервера, указав у них разные параметры delay-threshold. У одного выставим в none, у второго в 10 секунд. Это значит, что первый сервер будет обрабатывать все запросы, а если он перестанет отвечать, то каждый запрос, “протухший” на 10 секунд будет обработан вторым сервером.</p><p>Если быть точнее, то произойдет следующее:</p><p><img src=https://lh3.googleusercontent.com/4DxDHor-mRhcuUGCOaaEQ5xhXSYN86AFmGFzhOX6SKsM68-R-jL9znRIGM2OHSxRqfbMC9gW1dJV0ipmdxQ4ca1NbuynHZQkw32d_Ri9VtPJmjQpWrQoCqQakO70yrR8L1cV2c93 alt=DHCP_failover1.png></p><ol><li>Client &mdash;> DHCPDISCOVER  &mdash;> broadcast</li></ol><p>Этот пакет долетит до обоих серверов, но так как seconds elapsed=0, то ответит только тот сервер, у которого delay-threshold=none</p><ol start=2><li><p>Server1 &mdash;> DHCPOFFER &mdash;> broadcast</p></li><li><p>Client &mdash;> DHCPREQUEST &mdash;> broadcast</p></li><li><p>Server1 &mdash;> DHCPACK &mdash;> client</p></li></ol><p>Прошло lease-time/2. Server1 ещё жив</p><ol start=5><li><img src=https://lh3.googleusercontent.com/JGUgXmTYEXthDwlaSjwtLdaXINRf6_BdaSHpEtJvcWfqv6_XQ6XB7nZbqUWZ4Eeq2dcMRMgM5_14rdyQBmIu68XERE6XLwRKFpenm09eeQZ-ZC9JMJK43dozvAC6uUK_RVpmS0-b alt=DHCP_failover2.png>Client &mdash;> DHCPREQUEST &mdash;> server1</li></ol><p>Время аренды адреса продлилось до lease-time</p><ol start=6><li>Server1 &mdash;> DHCPACK &mdash;> client</li></ol><p>Где-то в этом промежутке сервер умер</p><p>Прошло lease-time/2.</p><ol start=7><li>Client &mdash;> DHCPREQUEST &mdash;> server1</li></ol><p>Этот пакет server1 не получит, потому что он умер. А до второго сервера пакет не долетит, так как предназначался первому и в dst-addr пакета указан только адрес server1</p><p>Через несколько миллисекунд</p><ol start=8><li>Client &mdash;> DHCPREQUEST &mdash;> server1</li></ol><p>Прошло ещё какое-то время и клиент сделал ещё несколько DHCPREQUEST’ов.</p><p>Прошло ещё lease-time/2 после пункта 7</p><ol start=9><li>Client &mdash;> DHCPDISCOVER &mdash;> broadcast</li></ol><p>Этот пакет не долетит до мертвого server1, но долетит до живого server2. Но обработан им не будет, так как elapsed seconds&lt;10</p><p>Ещё несколько пакетов DHCPDISCOVER ждет такая же судьба, как и 9. Пока не пройдет 10 секунд с пункта 9</p><ol start=10><li><img src=https://lh5.googleusercontent.com/ahXK8wH_iRUoSkFtdNJqtK4sOtrjNkzW24S_fO52hWf59jtBQgj09xNdX7ipirT8hgmUZ-BMMXAAvBo0b3JUDv4okxq_vTLQcmOidZTsgKd8awiUfCweCD3cYpH4zisU1ZrIa4Mg alt=DHCP_failover3.png>Client &mdash;> DHCPDISCOVER &mdash;> broadcast</li></ol><p>В этом пакете elapsed seconds=>10, а значит, его обработает server2</p><ol start=11><li><p>Server2 &mdash;> DHCPOFFER &mdash;> client</p></li><li><p>Client &mdash;> DHCPREQUEST &mdash;> broadcast</p></li><li><p>Server2 &mdash;> DHCPACK &mdash;> client</p></li></ol><p>        И всё по новой</p><p>Чего мы добились?</p><p>Если перестает отвечать один из серверов, то его обязанности берет на себя резервный сервер и продолжает поддерживать работу сети. При этом адреса, полученные клиентами, останутся при них, потому что протокол позволяет клиентам запрашивать определенный адрес, который обычно остается за интерфейсом.</p><p>Но что произойдет, если первый сервер вернется в работу? Клиенты продолжат работать со вторым, так как именно он отвечал им в DHCPACK. Казалось бы, такая ситуация нас вполне устраивает. Если бы не статические записи в таблице Leases, которые, как правило выдаются серверам или важным пользователям, чтобы применять к ним правила фаервола или шейпинга.</p><p>Допустим, первый сервер отказал ночью. Пользователи пришли на работу, включили компьютеры. А те начали запрашивать адреса у DHCP сервера. Но дизайнер может прийти раньше директора и получить у нового сервера VIP адрес. Ведь новый сервер ещё ничего не знает о статических записях. А директор в свою очередь, получит адрес секретарши, к IP адресу которой привязаны самые жесткие ограничения.</p><p>Значит, необходимо как-то синхронизировать базы данных DHCP серверов. В этом нам помогут замечательные скрипты RouterOS.</p><p>Основный сервер должен выгружать список адресов для аренды в файл:</p><pre tabindex=0><code>if (\[:len \[/file find name=leases.rsc\]\]&gt;0) do={/file remove leases.rsc}

/ip dhcp-server lease export file=leases.rsc
</code></pre><p>Вводим этот скрипт в планировщик. Выполняем задачу с нужной нам периодичностью.</p><p>На этом же роутере создадим группу FTP с правами ftp, read. И пользователя с таким же именем. Он будет нужен, чтобы резервный сервер мог скачать список leases.rsc</p><p>На резервном сервере в планировщик внесем скрипт, который скачивает список с основного сервера, чистит список адресов и импортирует его из файла.</p><pre tabindex=0><code>if (\[:len \[/file find name=leases.rsc\]\]&gt;0) do={/file remove leases.rsc}

/tool fetch mode=ftp address=192.168.1.1 src-path=leases.rsc user=FTP password=http://bubnovd.net

if (\[:len \[/file find name=leases.rsc\]\]&gt;0) do={

    foreach i in=\[/ip dhcp-server lease find \] do={

        /ip dhcp-server lease remove $i

    };

    import leases.rsc;

}
</code></pre><p>Теперь списки адресов будут синхронизироваться между серверами с той периодичностью, которая будет указана в планировщике. Я не рекомендую делать это слишком часто, так как любая запись на флеш роутера приближает её на шаг ближе к смерти.</p><p>Казалось бы задача выполнена. Служба DHCP зарезервирована. Сервера обмениваются информацией о статических записях. При поломке одного из серверов, всю работу берет на себя второй. После выключения хоста или при новом запросе  DHCPDISCOVERY, хост переключается на основной сервер.</p><p>Осталось одно маленькое неудобство. Скрипт, написанный ранее, синхронизирует записи server1 с server2. То есть, основная актуальная копия БД находится на одном сервере и все изменения, проделанные на server2 не будут реплицированы на server1. А вручную перебивать записи - не наш путь.</p><p>Можно, конечно, залить точно такой же скрипт на второй сервер и настроить их совместную работу. Но мы пойдем по другому пути.</p><p>Сделаем так, чтобы при включении в работу основного сервера, все клиенты в кратчайшее время перебрасывались на него и использовали актуальную версию базы адресов.</p><p>Этот метод не описан в RFC, и, вполне возможно, противоречит ему. Используйте на свой страх и риск!!! У меня работает =)</p><p>Для этого необходимо обмануть клиентов, указав в качестве src-addr DHCP сервера, адрес server1 даже если пакет улетает с server2. Тогда при операции DHCPREQUEST клиент будет всегда обращаться к server1. А если он не отвечает, то по истечении lease-time, будет инициирован DHCPDISCOVERY, на который после 10 секунд ответит второй - бэкапный сервер. И все клиенты будут возвращаться с бэкапного сервера на основной по истечении lease-time/2. И наоборот после lease-time.</p><p>В этом нам поможет параметр src-address. На резервном сервере укажем в качестве src-address адрес первого сервера и наслаждаемся отказоустойчивостью!</p><p>На этом всё! Служба DHCP зарезервирована. При отказе любого из DHCP серверов сеть продолжает работать, статические записи аренды синхронизируются. Конечно, тут мы не решили проблему отказа шлюза, но это не входило в тему поста. Поговорим об этом в следующих постах.</p><p>Приходите ко мне на <a href=http://mikrotik-ninja.ru/>курсы по Mikrotik</a>!</p><p>Дополнения.</p><ul><li><p>В ходе тестирования этого решения было замечено, что некоторые клиенты (телефоны Yealink) иногда в пакетах DHCPREQUEST указывают значение seconds elapsed=100. Благодаря чему могут получить адрес с резервного сервера, при живом основном. Лечится ребутом девайса.</p></li><li><p>На резервный сервер неплохо было бы прикрутить оповещение админа о том, что он начал выдавать адреса. Ведь если резервный начал выдавать адреса, значит основной не работает и его кто-то должен починить. Оповестить админа можно с помощью логов, отправленных на syslog сервер и обработанных должным образом, либо с помощью скрипта в lease-script. Первый способ мне кажется более предпочтительным и правильным.</p></li></ul><p>UPD: 18 июля был опубликован этот пост, а 25 на хабре вышла интересная статья об атаке на  DHCP с изложением принципов работы</p></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bubnovd-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://bubnovd.net/assets/main.js></script>
<script src=https://bubnovd.net/assets/prism.js></script></div></body></html>