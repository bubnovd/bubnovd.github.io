<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>windows on Bubnovd</title><link>https://bubnovd.github.io/tags/windows/</link><description>Recent content in windows on Bubnovd</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 07 Sep 2017 23:09:00 +0000</lastBuildDate><atom:link href="https://bubnovd.github.io/tags/windows/index.xml" rel="self" type="application/rss+xml"/><item><title>X Forwarding. Multiplatform</title><link>https://bubnovd.github.io/blogger/x-forwarding.-multiplatform/</link><pubDate>Thu, 07 Sep 2017 23:09:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/x-forwarding.-multiplatform/</guid><description>https://www.xpra.org/Кроссплатформенный сервер и клиент для проброса изображения (иксов) между системами</description><content>&lt;p>&lt;!-- raw HTML omitted -->&lt;a href="https://www.xpra.org/">https://www.xpra.org/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Кроссплатформенный сервер и клиент для проброса изображения (иксов) между системами&lt;/p></content></item><item><title>Управляем компьютером через Telegram</title><link>https://bubnovd.github.io/blogger/%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC-%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%BC-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-telegram/</link><pubDate>Thu, 31 Aug 2017 21:56:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC-%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%BC-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-telegram/</guid><description>RAT via Telegram способ управления машиной под управлением Windows командами из мессенджера Telegram.Что умеет:Работа с файлами и папкамиЗагрузка файловИсполнение файловСнятие скриншотовКейлоггерДоступ к микрофонуПрокси серверШифрование файловФункциональность больше пентестерская, чем админская, но всё равно интересная штука. Построен на Python</description><content>&lt;p>&lt;!-- raw HTML omitted -->RAT via Telegram&lt;!-- raw HTML omitted --> способ управления машиной под управлением Windows командами из мессенджера Telegram.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Что умеет:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Работа с файлами и папками&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Загрузка файлов&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Исполнение файлов&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Снятие скриншотов&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Кейлоггер&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Доступ к микрофону&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Прокси сервер&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Шифрование файлов&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Функциональность больше пентестерская, чем админская, но всё равно интересная штука. Построен на Python&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>LAPS (Local Administrator Password Solution)</title><link>https://bubnovd.github.io/blogger/laps-local-administrator-password-solution/</link><pubDate>Tue, 18 Jul 2017 21:19:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/laps-local-administrator-password-solution/</guid><description>Очень нужный инструмент. Сколько тысяч граблей было сломано в попытках решить то, что уже решено вендором.Материал тупо скопировав с telegra.ph, чтобы не потерять.Как оказалось, многие не знают, что давно есть бесплатное решение от Microsoft по управлению локальными паролями администраторов под названием LAPS (Local Administrator Password Solution). Я решил, что надо собрать подборку материалов, связанных с ЛАПСом, чтобы все было в одном месте. Часть материалов есть на русском, часть на сами знаете каком, но перед этим давайте разберемся для чего нужен LAPS:Безопасно хранить пароль локального администратора в Active Directory для каждой рабочей станции;Устанавливать правила сложности и длины пароля;Менять пароль локального администратора на устройстве через Active Directory;Устанавливать срок истечения времени действия пароля локального администратора и автоматически менять его.</description><content>&lt;p>Очень нужный инструмент. Сколько тысяч граблей было сломано в попытках решить то, что уже решено вендором.&lt;!-- raw HTML omitted -->Материал тупо скопировав с &lt;!-- raw HTML omitted -->telegra.ph&lt;!-- raw HTML omitted -->, чтобы не потерять.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как оказалось, многие не знают, что давно есть бесплатное решение от Microsoft по управлению локальными паролями администраторов под названием LAPS (&lt;!-- raw HTML omitted -->L&lt;!-- raw HTML omitted -->ocal &lt;!-- raw HTML omitted -->A&lt;!-- raw HTML omitted -->dministrator &lt;!-- raw HTML omitted -->P&lt;!-- raw HTML omitted -->assword &lt;!-- raw HTML omitted -->S&lt;!-- raw HTML omitted -->olution). Я решил, что надо собрать подборку материалов, связанных с ЛАПСом, чтобы все было в одном месте. Часть материалов есть на русском, часть на сами знаете каком, но перед этим давайте разберемся для чего нужен LAPS:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Безопасно хранить пароль локального администратора в Active Directory для каждой рабочей станции;&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Устанавливать правила сложности и длины пароля;&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Менять пароль локального администратора на устройстве через Active Directory;&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Устанавливать срок истечения времени действия пароля локального администратора и автоматически менять его.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Посты на русском: &lt;!-- raw HTML omitted -->Раз - &lt;!-- raw HTML omitted -->&lt;a href="https://www.atraining.ru/laps-local-administrator-password-solution/">https://www.atraining.ru/laps-local-administrator-password-solution/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Два - &lt;!-- raw HTML omitted -->&lt;a href="http://winitpro.ru/index.php/2015/05/07/ms-local-administrator-password-solution-upravlenie-parolyami-lokalnyx-administratorov-v-domene/">http://winitpro.ru/index.php/2015/05/07/ms-local-administrator-password-solution-upravlenie-parolyami-lokalnyx-administratorov-v-domene/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Скачать Local Administrator Password Solution (LAPS) версия 6.2 - &lt;!-- raw HTML omitted -->&lt;a href="https://www.microsoft.com/en-us/download/details.aspx?id=46899">https://www.microsoft.com/en-us/download/details.aspx?id=46899&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> Просто классика. Управление локальными паролями администраторов в восьми частях:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Overview - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/platformspfe/2013/10/22/managing-local-administrator-passwords/">https://blogs.technet.microsoft.com/platformspfe/2013/10/22/managing-local-administrator-passwords/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Random Password Generation - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/01/20/part-2-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/01/20/part-2-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Secure Active Directory Attribute Update - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/02/17/part-3-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/02/17/part-3-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Update Local Account&amp;rsquo;s Password - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/02/17/part-4-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/02/17/part-4-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Logging Function Output - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/02/17/part-5-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/02/17/part-5-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Extending The Active Directory Schema - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/04/02/part-6-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/04/02/part-6-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Completed Script - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/05/13/part-7-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/05/13/part-7-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Completed Secure Password Viewer - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/08/12/part-8-final-managing-local-administrator-passwords.aspx">https://blogs.technet.microsoft.com/b/platformspfe/archive/2014/08/12/part-8-final-managing-local-administrator-passwords.aspx&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->LAPS Audit Reporting via WEF PoSH and PowerBI&lt;!-- raw HTML omitted --> - &lt;!-- raw HTML omitted -->&lt;a href="https://blogs.technet.microsoft.com/kfalde/2015/11/18/laps-audit-reporting-via-wef-posh-and-powerbi/">https://blogs.technet.microsoft.com/kfalde/2015/11/18/laps-audit-reporting-via-wef-posh-and-powerbi/&lt;/a>&lt;!-- raw HTML omitted --> Весь архив лежит на гитхабе, включая отчет для PowerBI - &lt;!-- raw HTML omitted -->&lt;a href="https://github.com/kurtfalde/LAPS-Reporting">https://github.com/kurtfalde/LAPS-Reporting&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Microsoft LAPS и Configuration Manager&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Расширение для консоли (работает с SCCM 2012 R2 CU1 и SCCM Current Branch: 1511, 1602, 1606), которое позволяет просматривать пароли для устройств - &lt;!-- raw HTML omitted -->&lt;a href="https://gallery.technet.microsoft.com/LAPS-Extension-for-SCCM-e8bd35b1">https://gallery.technet.microsoft.com/LAPS-Extension-for-SCCM-e8bd35b1&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Описание по созданию Configuration Items для LAPS - &lt;!-- raw HTML omitted -->&lt;a href="https://4sysops.com/archives/monitoring-laps-with-configuration-manager/">https://4sysops.com/archives/monitoring-laps-with-configuration-manager/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->FAQ в 2-х частях (англ.):&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;a href="https://4sysops.com/archives/faqs-for-microsoft-local-administrator-password-solution-laps/">https://4sysops.com/archives/faqs-for-microsoft-local-administrator-password-solution-laps/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;a href="https://4sysops.com/archives/part-2-faqs-for-microsoft-local-administrator-password-solution-laps/">https://4sysops.com/archives/part-2-faqs-for-microsoft-local-administrator-password-solution-laps/&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Видео:&lt;!-- raw HTML omitted -->Taste of Premier: How to tackle Local Admin Password Problems in the Enterprise with LAPS - &lt;!-- raw HTML omitted -->&lt;a href="https://channel9.msdn.com/Blogs/Taste-of-Premier/Taste-of-Premier-How-to-tackle-Local-Admin-Password-Problems-in-the-Enterprise-with-LAPS">https://channel9.msdn.com/Blogs/Taste-of-Premier/Taste-of-Premier-How-to-tackle-Local-Admin-Password-Problems-in-the-Enterprise-with-LAPS&lt;/a>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Этих ребят я обожаю, у них клевые видео по безопасности - &lt;!-- raw HTML omitted -->Microsoft Local Admin Password Solution (LAPS) – Deployment Steps &lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>Годный пост про семейство ARP</title><link>https://bubnovd.github.io/blogger/%D0%B3%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D1%80%D0%BE-%D1%81%D0%B5%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%BE-arp/</link><pubDate>Mon, 30 Jan 2017 03:12:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/%D0%B3%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D1%81%D1%82-%D0%BF%D1%80%D0%BE-%D1%81%D0%B5%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%BE-arp/</guid><description>Заслуживающий отдельного внимания пост про семейство протоколов ARP и особенности их работы на Windows от Руслана КармановаОригинал тут. Я просто скопипастил весь текстСемейка протокола ARPПротокол ARP вроде бы простой и тривиальный, но количество его однофамильцев с различным функционалом - достаточно серьёзно. Разбираемся.Привет.Многие думают, что если протокол мелкий и незаметный, то про него не надо ничего знать. Нетрудно догадаться, что это не так, и именно детальное знание подобных низкоуровневых задач является тем, что отличает профессионала от гуглоиксперта или фанатика, верующего, что в его любимой ОС всё работает “само по себе и априори идеально”.</description><content>&lt;p>Заслуживающий отдельного внимания пост про семейство протоколов ARP и особенности их работы на Windows от &lt;!-- raw HTML omitted -->Руслана Карманова&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Оригинал &lt;!-- raw HTML omitted -->тут&lt;!-- raw HTML omitted -->. Я просто скопипастил весь текст&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Семейка протокола ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол ARP вроде бы простой и тривиальный, но количество его однофамильцев с различным функционалом - достаточно серьёзно. Разбираемся.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Привет.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Многие думают, что если протокол мелкий и незаметный, то про него не надо ничего знать. Нетрудно догадаться, что это не так, и именно детальное знание подобных низкоуровневых задач является тем, что отличает профессионала от гуглоиксперта или фанатика, верующего, что в его любимой ОС всё работает “само по себе и априори идеально”.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Оглавление&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> Вкратце про сам протокол и формат заголовка&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> Базовый тюнинг – тайм-ауты и кэш&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> ARP и QoS&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> ARP и NLB&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> ARP и SNAP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> ARP и NUD&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> ARP и DAD&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> ARP и WOL&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и РПГ-7&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол RARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол InARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол UNARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол SLARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол DirectedARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Безопасность ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Механизм Proxy ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Что такое и как работает Gratuitous ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Cisco ARP Optimization Feature – что это?&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как работает протокол ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол Address Resolution Protocol (ARP) используется для простой задачи – выяснить по известному адресу сетевого уровня (IP) неизвестный адрес канального уровня (например MAC). Данные ARP вкладываются в протокол канального уровня и являются, по уровню вложения, протоколом 3го уровня, а вот по функционалу остаются протоколом 2го уровня. Это я к тому, что модель OSI надо знать не хорошо, а очень хорошо. Для идентификации ARP внутри кадра Ethernet будет использоваться код протокола &lt;!-- raw HTML omitted -->0x0806&lt;!-- raw HTML omitted -->. В состав ARP-пакета будет входить следующие интересные поля:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Тип оборудования (длина поля – 2 байта): Код, обозначающий тип среды, в которой идёт работа. Для Ethernet’ов это будет единица, готы могут ставить 5 (для протокола Chaos), эстеты – 149.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Тип протокола сетевого уровня, про который идёт речь в ARP-пакете (длина поля – 2 байта): Стандартный код протокола, такой же, как в 802.3, например. То есть для IPv4 – это &lt;!-- raw HTML omitted -->0x0800&lt;!-- raw HTML omitted -->.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Длина адреса канального уровня (длина поля – 1 байт): Сколько байт в адресе канального уровня. Например, для 802.3 это будет 6.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Длина адреса сетевого уровня (длина поля – 1 байт): Сколько байт в адресе сетевого уровня. Например, для IPv4 это будет 4.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Код операции ARP (длина поля – 2 байта): У операции ARP Request это единица, у ARP Response – двойка. Да, такой вот обильный в плане функционала протокол. :)&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Адрес канального уровня отправителя (SRC MAC, говоря проще) – уникастовый MAC-адрес интерфейса, с которого отправляется запрос.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Адрес сетевого уровня отправителя (SRC IP, говоря проще) – уникастовый IP-адрес интерфейса, с которого отправляется запрос. В случае нескольких IP-адресов на интерфейсе – основной адрес интерфейса (primary).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Искомый адрес канального уровня – в случае ARP – широковещательный 802.3 адрес вида FF-FF-FF-FF-FF-FF. Ведь очевидно, что раз делается ARP-запрос вида “я знаю только искомый IP-адрес”, то искомый адрес канального уровня неизвестен, поэтому сюда пишется “заглушка” из броадкаста. На фактическое распространение она не влияет, т.к. в самом Ethernet-кадре, в котором вложен ARP-запрос, уже указан броадкаст как DST MAC.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Искомый адрес сетевого уровня – в случае ARP – тот самый IP-адрес, для которого надо найти соответствующий MAC.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Задачи, стоящие перед протоколом, достаточно прозрачны. Как он будет настраиваться?&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Базовые операции с ARP для Windows&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Почистить локальный кэш ARP или удалить отдельную запись&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Кэш: &lt;!-- raw HTML omitted -->arp -d&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Запись: &lt;!-- raw HTML omitted -->arp -d &lt;!-- raw HTML omitted -->ip-адрес&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Добавить статическую ARP-запись&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->arp -s &lt;!-- raw HTML omitted -->ip-адрес&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->mac-адрес&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Детально посмотреть кэш&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->arp -a -v&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Будут видны все типы записей – и static, и dynamic, и invalid. Сам вывод будет разбит по критерию привязки записей к интерфейсам – в начале каждого раздела будет выводиться primary IP интерфейса, а потом его внутренний идентификатор (Вы можете посмотреть табличку интерфейсов и их ID командой &lt;!-- raw HTML omitted -->netsh int ipv4 sh int&lt;!-- raw HTML omitted -->).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Есть и более современный вариант отображения кэша:&lt;!-- raw HTML omitted -->netsh interface ipv4 show nei&lt;!-- raw HTML omitted -->. В этой команде вывод также разбит по интерфейсам (правда, пишутся их человеческие названия, а не primary IP), статические и системные записи будут называться Permanent, обычные – Reachable (если доступны), Unreacheable (если нет) и Stale (если запись устарела).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Базовые операции с ARP на оборудовании Cisco&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как добавить статическую запись&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config)#arp &lt;!-- raw HTML omitted -->ip-адрес или “vrf имя-vrf”&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->mac-адрес&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->тип-вложения&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->тип-интерфейса&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Из интересного тут разве что тип вложения – можно указать, какой именно вариант вложения (из реально возможных сейчас – ARPA или SNAP) будет у записи. Параметр “Тип интерфейса” можно не указывать.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Настроить включение-выключение ARP и его тип&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config-if)#arp &lt;!-- raw HTML omitted -->arpa или frame-relay или snap&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как понятно, обычно тип ARP будет ARPA и в модификации нуждаться тоже особо не будет. Внимание – типы не являются взаимоисключающими – т.е. можно сделать и &lt;!-- raw HTML omitted -->arp arpa&lt;!-- raw HTML omitted --> и &lt;!-- raw HTML omitted -->arp snap&lt;!-- raw HTML omitted -->, и это лишь покажет, что на данном интерфейсе надо обрабатывать и тот и тот варианты.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Настроить время нахождения записи в ARP-кэше&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config-if)#arp timeout &lt;!-- raw HTML omitted -->секунды&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Настройка идёт на интерфейсе, т.к. данный тайм-аут будет только у записей в ARP-кэше, сделанных через этот интерфейс.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Очистить кэш ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Весь:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->#clear arp-cache&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Отдельную запись:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->#clear arp-cache &lt;!-- raw HTML omitted -->ip-адрес&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Все записи, привязанные к конкретному интерфейсу:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->#clear arp-cache &lt;!-- raw HTML omitted -->интерфейс&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Настроить работу с incomplete ARP records&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Данные настройки будут нужны, чтобы задать поведение системы в случае “Я точно знаю, что есть сосед с таким IP-адресом, но у меня нет его MAC-адреса”.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Вы можете задать общее число таких адресов, находящихся “в процессе поиска”, а также количество попыток&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Включение:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config)#ip arp incomplete enable&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Количество адресов:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config)#ip arp incomplete entries &lt;!-- raw HTML omitted -->число&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Количество попыток:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config)#ip arp incomplete retry &lt;!-- raw HTML omitted -->число&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Базовый тюнинг ARP – тайм-ауты и кэш&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->В NT 6.0 сетевой стек был ощутимо изменен (приведён в соответствие с RFC 4861), поэтому то, что действовало для XP/2003, работать в большинстве своём не будет. Схема работы ARP-кэша теперь следующая:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Есть кэш “соседей” – для IPv4 и IPv6&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Запись туда идёт после получения ARP-ответа, после чего у строки кэша появляется статус “Reachable”&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Статус теряется в случае отказа интерфейса или по тайм-ауту – если прошло более “ReachableTime” секунд, то статус меняется на “Stale”&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Если хочется отправить пакет узлу, строка кэша для которого находится в состоянии “Stale”, то предварительно надо отправить ARP-запрос&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как точнее считается время? Формула подсчёта такова:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ReachableTime = BaseReachableTime * (случайный коэффициент между MIN_RANDOM_FACTOR и MAX_RANDOM_FACTOR)&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Параметры, от которых идёт вычисление, выглядят так: BaseReachableTime = 30 секунд, MIN_RANDOM_FACTOR = 0.5, а MAX_RANDOM_FACTOR – 1.5. Параметр BaseReachableTime изменяем командой:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->netsh interface ipv4 set interface &lt;!-- raw HTML omitted -->имя интерфейса&lt;!-- raw HTML omitted --> basereachable=&lt;!-- raw HTML omitted -->количество миллисекунд&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Заметьте, для каждого интерфейса это устанавливается отдельно. Ранее действовавшее общесистемное значение по умолчанию в 120 секунд, таким образом, теперь не актуально. Я бы рекомендовал увеличить это значение до тех же 2х минут, что были раньше – количество трафика снизится, а минусов практически нет – узлы, которые сменят MAC за время устаревания кэша, сами об этом уведомят.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->В случае работы с оборудованием Cisco, данный параметр – тайм-аут записи в ARP-кэше – задаётся на интерфейсе командой:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->arp timeout &lt;!-- raw HTML omitted -->время в секундах&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->и имеет базовое значение в 14400 (это 4 часа).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Суммарный же объём кэша IPv4-соседей можно установить так:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->netsh interface ipv4 set global neighborcachelimit=&lt;!-- raw HTML omitted -->количество&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->По умолчанию их 256. Как понятно, в случае, если соседей по среде передачи данных мало (например, есть единственный сетевой интерфейс в сеть с маской /28), этот кэш увеличивать не надо, а уменьшить вполне можно. Помните, это именно кэш ARP, т.е. явных адресов соседей по vlan плюс служебных мультикастов. Нет смысла его раздувать до огромных габаритов, если в сети банально мало узлов, нечего кэшировать особо будет.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Давайте теперь чуть углубимся.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и QoS&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->В случае, когда сетевой интерфейс загружен трафиком, часть трафика может теряться. Увы, ни один из методов queuing не является от этого панацеей. Начиная с Cisco IOS 15.1 можно указать, что на данном интерфейсе необходимо всегда обрабатывать ARP-пакеты в первую очередь, что может значительно сократить процент потери ARP-данных. На общую загрузку это, как понятно, повлияет мало, а вот пользы может принести много. Ведь ARP-пакеты передаются без механизма подтверждения доставки и терять их не очень хорошо.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Данный механизм включается на L3-интерфейсах, командой:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->arp packet-priority enable&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Выключается, как понятно, &lt;!-- raw HTML omitted -->no arp packet-priority enable&lt;!-- raw HTML omitted -->. В Windows аналогичной процедуры нет.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и NLB&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Чтобы ARP дружил с NLB, он должен обрабатывать ситуацию, когда придёт ARP-запрос с не-юникастового адреса. То есть, смотрите ситуацию. Допустим, есть NLB, который работает в мультикастовом режиме. Два хоста, соответственно, прикидываются одним IP-адресом, отвечая на ARP-запросы про этот адрес общим мультикастовым MAC’ом, и потом договариваясь друг меж другом, что делать с пришедшим трафиком. Вот чтобы эта схема работала, надо, чтобы когда этот “общий виртуальный узел”, который обладает виртуальным IP и мультикастовым MAC, решил узнать через ARP чей-то MAC, ему вообще ответили. Потому что есть тонкость – у мультикастового MAC есть характерный вид, по которому понятно, что он мультикастовый. А не-юникастовые source MAC в общем-то не являются нормальной ситуацией и нуждаются в особой обработке. Соответственно, для этого надо явно включить обработку ситуации “к нам пришёл ARP-запрос от товарища, у которого обратный MAC-адрес не-юникастовый”. Делается это путём установки параметра:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\EnableBcastArpReply&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->в единицу. Если она будет в нуле – в ряде ситуаций поимеете проблемы с NLB.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и SNAP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->По умолчанию, ARP вкладывается в 802.3 кадр простым, Ethernet II способом. Это можно поменять в случае, если необходима поддержка SNAP-механизма, который, как известно, нужен для мультиплексирования потоков данных на канальном уровне. Напомню, что по RFC 1042 данные IP и ARP всегда передаются поверх 802.x сетей используя связку LLC+SNAP, за исключением обычного Ethernet (802.3), где они вкладываются напрямую (см. RFC 894).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: Если не известно, то надо задуматься об изучении курса ICND1, потому что детальное рассмотрение “что такое SNAP, зачем, почему, когда, с кем” не входит в спектр задач по изучению ARP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Для этой задачи есть ключ:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\ArpUseEtherSNAP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->По умолчанию он в нуле, установив в единицу Вы получите ситуацию, что ARP-запросы будут вкладываться в SNAP (притом в LLC+SNAP, что увеличит суммарный размер кадра на 3+5=8 байт).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и NUD&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->NUD – это Neighbor Unreachability Detection. По умолчанию включается на интерфейсах, которые смотрят в broadcast-среды, и выключается на других. Помогает узнать о том, что сосед (что обычный, что шлюз) перешёл в нефункциональное состояние до времени, пока его запись в ARP-кэше стала Stale. Механизм полезный, поэтому его рекомендуется включать в явном виде. Делается это командой:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->netsh int ipv4 set int &lt;!-- raw HTML omitted -->имя интерфейса&lt;!-- raw HTML omitted --> nud=enabled&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и DAD&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->DAD – это Duplicate Address Detection. То самое, что не даёт взять себе адрес, который уже есть у кого-то. Проводится путём отправки Gratuious ARP, про который чуть ниже. Тюнингуется достаточно просто, двумя параметрами:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->netsh int ipv4 set int &lt;!-- raw HTML omitted -->имя интерфейса&lt;!-- raw HTML omitted --> retransmittime=&lt;!-- raw HTML omitted -->миллисекунды&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->netsh int ipv4 set int &lt;!-- raw HTML omitted -->имя интерфейса&lt;!-- raw HTML omitted --> dadtransmits=&lt;!-- raw HTML omitted -->попытки&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->По умолчанию &lt;!-- raw HTML omitted -->retransmittime&lt;!-- raw HTML omitted --> – т.е. время между попытками обнаружить соседа, который уже занял адрес – 1 секунда, количество попыток &lt;!-- raw HTML omitted -->dadtransmits&lt;!-- raw HTML omitted --> – 3. Можете сократить их, если уверены, что все соседи отвечают достаточно быстро, это уменьшит время инициализации интерфейса – система не будет ждать “вдруг кто проснётся и скажет, что адрес уже занят”.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP и WOL&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Функция Wake-On-Lan, думается, хорошо Вам известна. Она нужна, чтобы узел “проснулся” в определённый момент – когда увидит на сетевом интерфейсе соответствующие неким условиям данные. Обычно это данные, напрямую идущие на данный узел, притом содержащие некую последовательность – Magic Pattern. Так вот, можно заранее указать условие – будет ли данный Magic Pattern искаться вообще во всех сетевых данных, которые попадут на нужный узел, либо только не некоторых. В частности, так как статья про ARP, есть настройка, позволяющая установить для интерфейса условие – анализировать ли на предмет наличия Magic Pattern’а пакеты протоколов ARP (для IPv4) и ND (для IPv6). Включается следующим образом:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->netsh int ipv4 set int &lt;!-- raw HTML omitted -->имя интерфейса&lt;!-- raw HTML omitted --> forcearpndwolpattern=enabled&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как выключается, надеюсь, понятно. Рекомендуется к выключению на узлах, у которых нет задачи просыпаться по WOL, т.к. ускоряет обработку путём раннего отбрасывания механизмом поиска Magic Pattern указанных пакетов.&lt;!-- raw HTML omitted -->Теперь про RARP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол RARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->RARP – это как ARP, только наоборот. Логично. По сути, RARP – это очень сильно простой сервис по динамическому конфигурированию узлов. Он ведь отрабатывает задачу, обратную ARP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ARP: Я знаю искомый L3-адрес, дайте мне соответствующий ему L2-адрес.&lt;!-- raw HTML omitted -->RARP: Я знаю искомый L2-адрес, дайте мне соответствующий ему L3-адрес.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: Обратите внимание, для работы ARP выделенный сервер не нужен, а для RARP – нужен.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->У RARP-сервера есть табличка соответствий MAC и IP-адресов, из которой он берёт указанную информацию и отправляет её. Различия на технологическом уровне будут следующими: RARP-пакеты будут иметь код вложения &lt;!-- raw HTML omitted -->0x8035&lt;!-- raw HTML omitted -->, плюс коды операций у них будут 3 для RARP-запроса и 4 для RARP-ответа.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: Если код вложения будет от RARP, а коды – 1 или 2 (т.е. как у обычного ARP), то RARP-сервер отдаст данный пакет на обработку ARP-стеку.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Вообще, RARP сейчас практически не используется, но если хотите почитать – есть RFC 903.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: А если хотите почитать, и чтобы накрыло – почитайте про Dynamic RARP, это RFC 1931.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Реализация RARP-сервера в Windows&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Её нет. Если хочется стороннее решение, то можно &lt;!-- raw HTML omitted -->скачать RARP windows server быстро бесплатно без sms&lt;!-- raw HTML omitted -->.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Реализация RARP-сервера на оборудовании Cisco&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Она есть. Конфигурируется в несколько этапов. По порядку:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Шаг первый: Добавляем запись для потенциального RARP-клиента (т.е. того, кто хочет получить IP-адрес). В глобальной конфигурации:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config)#arp &lt;!-- raw HTML omitted -->ip-адрес&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->mac-адрес-клиента&lt;!-- raw HTML omitted --> arpa&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Шаг второй: Разрешаем на интерфейсе, в качестве параметра – тот адрес на интерфейсе, от которого отправляем RARP-ответы.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config-if)#ip rarp-server &lt;!-- raw HTML omitted -->ip-адрес&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол InARP (Inverse ARP)&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->InARP – специальная модификация ARP для не-broadcast сетей (например, Frame Relay или ATM). Суть проста – в сетях, где нет широковещания, обычный ARP работать не сможет, а задачи, которые им решаются, никуда не пропадают. Соответственно, нужна схема работы. Она будет достаточно интересна и проста. Узел, который поддерживает InARP, будет самостоятельно с указанной периодичностью отправлять в субинтерфейсы, поддерживающие InARP (например, в FR’овские), InARP-сообщения, в которых будет указано что-то вида “привет, я от узла с сетевым адресом таким-то”. Соответственно, принимающая сторона, получая такое сообщение из-под субинтерфейса с DLCI=xxx, будет записывать у себя в таблицу – “За DLCI xxx живёт товарищ с IP yyy”. В общем-то и всё.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Другие отличия будут состоять в использовании других кодов операций – 8 для запроса InARP, 9 для ответа. Ну и в механизме вложения – понятное дело, в Q.922 вкладываться – это не в 802.3&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол UnARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Предлагался в RFC 1868. Суть проста – сам формат пакета ARP не менялся, добавлялся лишь новый тип сообщения – сообщение вида “Я ушёл из сети”. Т.е. задачей дополнения UNARP являлось то, что узлы, которые отключаются, могут послать сообщение “Стирайте меня все из ARP-кэшей”, чтобы остальные не ждали время окончания кэширования записей. К сожалению, не поддерживается (основная причина – небезопасен, т.к. такое сообщение легко подделать).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол SLARP (Serial Line ARP)&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Специальный субпротокол, работающий внутри цисковского варианта HDLC (который обычно cHDLC). Используемый код вложения – &lt;!-- raw HTML omitted -->0x8035&lt;!-- raw HTML omitted -->. Протокол простой, но интересный тем, что может делать две штуки – проверять состояние канала, периодически передавая кадры, и назначать IPv4-адреса в случае, если с одной стороны serial link адрес IPv4 есть, а с другой – нет. Адрес назначается по логике “Если у меня последний бит адреса 1, предложить такой же, но с нулём, и наоборот”. Маска предлагается такая же, как у себя.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Формат кадра будет такой:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Адрес (один байт) – стандартный адрес вида b1111111 из xHDLC/PPP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Контроль (один байт) – то же самое, опять LLC3, т.е. b00000011.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Код протокола вложения (два байта) – личный номер SLARP, &lt;!-- raw HTML omitted -->0x8035&lt;!-- raw HTML omitted -->.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Код операции (один байт) – вариант или Address request(0x00), или address reply (0x01), или Keep-alive (0x02).&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->IPv4-адрес и маска (два раза по 4 байта) – предлагаемый партнёру по serial link адрес.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Резерв (один байт) – вечно 0xFF.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->FCS в варианте CRC-16 (два байта)&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Флаг (один байт) – стандартный флаг xHDLC вида b0111110.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол DirectedARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Протокол описан в RFC 1433. Сейчас как отдельный протокол не используется, хотя многие мысли, высказанные в этом RFC, достаточно дельные и повлияли, например, на формирование современного IPv6.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Безопасность ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->В общем-то, в ARP нет никаких встроенных средств безопасности. Это очень простой служебный протокол, поэтому о какой-то отдельной защите его говорить трудно. Можно высказать лишь общие мысли – например, что в случае малого количества хостов проще ввести все их IP-MAC соответствия как статические – в этом случае ARP они передавать перестанут (в кэше-то записи про соседей будут всё время), а если кто-то злонамеренный специально передаст поддельный ARP-ответ, то никакого влияния он не окажет – динамически полученный ARP-ответ не перезапишет собой статическую запись.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Есть ряд дополнительных механизмов (которых достаточно много), которые могут помочь в этом вопросе. Например, на оборудовании Cisco есть команда:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->arp authorized&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->которая, в случае включения на интерфейсе, отключит динамические записи в кэш ARP. Т.е. интерфейс перестанет слушать ARP-ответы от неизвестных клиентов и дополнять ими кэш ARP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Для ряда моделей оборудования (например, на старших линейках маршрутизаторов – это 7600) можно задать в режиме глобальной конфигурации максимальный размер ARP-кэша для устройства (по умолчанию он не ограничен и составляет 256.000 записей):&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->ip arp entry learn &lt;!-- raw HTML omitted -->количество&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Есть, в общем-то, множество доп.механизмов безопасности ARP – тот же DAI или ARP ACL, про которые, возможно, я тоже допишу сюда.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Механизм Proxy ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Суть механизма Proxy ARP, детально обозначенного в RFC 1027, проста – дать возможность узлу, который в силу каких-то причин (например, у него не указан шлюз по умолчанию) не может понять, куда маршрутизировать трафик для других сетей, всё же сделать это. Притом сделать просто – используя то, что в сегменте с этим узлом присутствует добрый узел, на котором включен Proxy ARP, и который, увидев что узел пытается через ARP-запрос найти получателя трафика, “прикинется” этим получателем и ответит на запрос.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Т.е. вот есть маршрутизатор, на котором включен Proxy ARP. Он получает ARP-запрос на разрешение адреса узла, который находится в другом сегменте относительно спрашивающего и помогает – просто отвечает ему от имени этого узла. Соответственно, этот роутер и будет передавать трафик между данными узлами, а отправитель будет думать, что отправляет трафик напрямую.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Данный механизм включен “по умолчанию” на большинстве систем и нуждается в отключении – т.е. описанная ситуация, в общем-то, по производственной необходимости возникает довольно-таки редко.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Пример: Например, у хоста A адрес 10.1.1.1/24, а у хоста B – 10.1.1.2/16. Технологически они в разных сетях, и между ними даже есть роутер – у него в сторону хоста A смотрит интерфейс 10.1.1.254/24, в сторону хоста B – 10.1.255.254/16. Но вот проблема в том, что хост A не понимает, что хост B – в другой сети, а думает, что B – его сосед. И пытается найти его, отправляя ARP-запрос. Вот в этом случае если роутер будет поддерживать Proxy ARP, то всё будет хорошо – связь между A и B будет.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как включить Proxy ARP на оборудовании Cisco&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Зайдите на нужный интерфейс и введите там команду:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(config-if)#ip proxy-arp&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Выключить глобально – &lt;!-- raw HTML omitted -->(config)#ip arp proxy disable&lt;!-- raw HTML omitted -->.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как включить Proxy ARP в Windows&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->В случае, когда у Вас используется RRaS, proxy ARP работает автоматически.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Что такое и как работает Gratuitous ARP&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Это страшное слово переводится как “самопроизвольный” ARP. Суть события в следующем. Любой узел, который инициирует новый интерфейс, на котором есть поддержка ARP, должен при завершении процесса конфигурирования IP-адреса (статически ли, по DHCP, через APIPA’у – без разницы) уведомить соседей о том, что он появился. Делается это при помощи отправки одиночного ARP Reply, в котором указывается, что логично, связка “мой MAC – мой новый IP”. Т.е. выглядит этот ARP-ответ несколько странно с точки зрения классической схемы работы ARP – узел рассылает на броадкастовый MAC и свой IP информацию о своём настоящем MAC и своём же IP. Т.е. совпадают SRC IP и DST IP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: По сути, этот механизм – это “форсированное” обновление ARP-кэша соседей новой информацией – “теперь я по этому MAC-адресу”. Заодно, именно благодаря этому механизму, происходит обнаружение дублирующихся IP-адресов – тот, кто пытается присвоить себе IP-адрес, рассылая это уведомление “засветится”.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Но, в общем-то, мы и договорились, что это – исключительная и разовая ситуация. Казалось бы, в чём проблема-то?&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Проблема в том, что когда такое происходит на сервере удалённого доступа, к которому подключено несколько клиентов (более 1, по сути), то этот сервер при подключении каждого своего клиента получает от него данный стартовый запрос ARP и ретранслирует запрос далее, выступая, по сути, прокси. В результате, допустим, порт коммутатора, в который включен этот сервер, впадает в тягостные размышления о здоровье сервера, который постоянно сообщает всей сети о том, что за его MAC-адресом интерфейса (того, который воткнут в коммутатор) очень много IP-адресов, и все они разные. И каждый раз, когда клиент будет подключаться (например, VPN-канал переподключит, или другим способом вызовет переход через NCP-фазу PPP), такой ARP-ответ будет создаваться и отправляться серверу, а тот будет отдавать его дальше – чтобы уведомить сеть, что трафик на такой-то IP-адрес надо отправлять на его, сервера, MAC, а дальше он уж сам разберется.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Соответственно, в ряде ситуаций (например, много клиентов, краткие сессии) такой механизм надо отключать. Зачастую проще привязать статически целую пачку ARP-соответствий (например, когда на сервере удалённого доступа выделен пул в 20 адресов, и абоненты подключаются, делают какую-то краткую операцию и отключаются), чем постоянно форвардить в сеть эти ARP Reply.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: На самом деле, делать это надо с умом, как и всё остальное. Есть ситуации, когда gratuitous ARP является штатным и нужным. Например, у Вас сделан HSRP-балансировщик. Активный узел упал – второй становится активным. И в этот момент он тоже “просто так, внезапно” отправит gratuitous ARP – чтобы сразу уведомить всю сеть, что теперь у виртуального IP новый MAC, а не ждать, пока у всех узлов кончится тайм-аут кэша.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как настроить Gratuitous ARP на оборудовании Cisco&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Включить:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->router(config)#ip gratuitous-arps&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Если добавить в конце команды слово non-local, то будет обрабатываться вышеописанная ситуация с PPP.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Отключить приём всех gratuitous ARP’ов:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->router(config)#ip arp gratuitous none&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Включить приём только gratuitous ARP’ов, source которых из connected-сетей:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->router(config)#ip arp gratuitous local&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как настроить Gratuitous ARP на Windows Server&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Для указанного сценария с RRaS – никак. Ваш RRaS-сервер не будет передавать стартовый ARP-запрос, полученый от PPP-клиента, в другие сети, поэтому ситуация, описанная выше, просто не возникнет.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Управлять же Gratuitous ARP со стороны узла вполне можно. Для этого есть ключ реестра:&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->HKLM\System\CurrentControlSet\Services\TcpIp\Parameters&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->а в нём – параметр &lt;!-- raw HTML omitted -->ArpRetryCount&lt;!-- raw HTML omitted --> типа DWORD32. Если поставить этот параметр в нуль, то механизм будет выключен. По умолчанию Windows-хосты делают Gratuitous ARP три раза – сразу после инициализации адреса, потом через 1/2 секунды, потом через ещё 1/10 секунды. Можете поставить единицу, если уверены в качестве работы сети и её не-критичной загруженности на момент выхода ARP Reply – “сэкономите трафик”.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: Считаются фактически отправленные ARP, а не попытки. Т.е. если среда была недоступна, то все равно отправят три, просто чуть позже.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Примечание: Если поставить нуль, то вдобавок отвалится функция обнаружения конфликтов DHCP, но это будет в другой истории.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Cisco ARP Optimization Feature – что это?&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Это достаточно полезное архитектурное изменение, появившееся в релизах IOS 12.0 – 12.2 и закрепившееся в более поздних. Идея проста. Устройство хранит информацию о связках IP-MAC-интерфейс в отдельной таблице. Эта таблица организована для быстрого поиска информации по известному IP-адресу. Соответственно, этот механизм эффективен, когда надо обработать единичный пакет. В ситуации же, когда интерфейс попеременно переходит из состояния включения в выключенное и наоборот (interface flapping), надо сразу же обработать в этой таблице все ARP-записи, относящиеся ко всем IP и MAC, находящимся за данным интерфейсом. Вот фича Cisco ARP Optimization как раз умеет делать эту операцию – например, очистить все записи за соответствующий интерфейс. Выигрыш – резко сниженная загрузка CPU, которому надо обработать событие “падение интерфейса”.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Как настроить Cisco ARP Optimization Feature&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Никак – это просто другая структура хранения данных ARP в оперативной памяти, используемая в современных версиях IOS.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Заключение&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Если я вспомню ещё что-то, или меня наведут на мысль, то обязательно напишу сюда в качестве дополнения к статье.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>Как Windows работает с несколькими шлюзами по умолчанию</title><link>https://bubnovd.github.io/blogger/%D0%BA%D0%B0%D0%BA-windows-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D1%81-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D0%BC%D0%B8-%D1%88%D0%BB%D1%8E%D0%B7%D0%B0%D0%BC%D0%B8-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E/</link><pubDate>Mon, 20 Jul 2015 23:56:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/%D0%BA%D0%B0%D0%BA-windows-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D1%81-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D0%BC%D0%B8-%D1%88%D0%BB%D1%8E%D0%B7%D0%B0%D0%BC%D0%B8-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E/</guid><description>Для обеспечения отказоустойчивости сетей применяется практика использования нескольких шлюзов по умолчанию. В таком случае при доступности одного из шлюзов, трафик будет идти через него (шлюзы не эквивалентны, постоянно активен только один). При отказе этого шлюза, трафик пойдет через второй шлюз. С соединениями по TCP проблем это не создаст. Единственное, TCP коннект должен будет пересоединиться по новому маршруту после завершения таймаута соединения. С трафиком же UDP могут возникнуть проблемы при переключении шлюза - телефония начнет заикаться, видео будет пропадать.</description><content>&lt;p>Для обеспечения отказоустойчивости сетей применяется практика использования нескольких шлюзов по умолчанию. В таком случае при доступности одного из шлюзов, трафик будет идти через него (шлюзы не эквивалентны, постоянно активен только один). При отказе этого шлюза, трафик пойдет через второй шлюз. С соединениями по TCP проблем это не создаст. Единственное, TCP коннект должен будет пересоединиться по новому маршруту после завершения таймаута соединения. С трафиком же UDP могут возникнуть проблемы при переключении шлюза - телефония начнет заикаться, видео будет пропадать. Но по прошествии какого-то времени проблема исчезнет. А как Windows определяет доступность шлюза? Об этом ниже.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Когда TCP-соединение маршрутизируется через основной шлюз, хост пытается отправить пакет к получателю столько раз, сколько указано в ключе реестра &lt;!-- raw HTML omitted -->TcpMaxDataRetransmissions, &lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->деленное пополам. И если ответ от получателя за это количество попыток ни разу не пришел, то алгоритм меняет &lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Route Cache Entry (RCE)&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->(кэш маршрутов). Наше соединение (отправившее TcpMaxDataRetransmissions/2 пакетов и не получившее ни одного ответа) переключается на шлюз, указанный вторым в настройках адаптера. Когда 25% TCP-соединений переключатся на второй шлюз, он становится шлюзом по умолчанию. Новый шлюз по умолчанию будет использоваться до возникновения аналогичных проблем с ним, либо до перезагрузки системы.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Вольный перевод &lt;!-- raw HTML omitted -->KB&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->171564&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>Материалы по Windows Server 2012R2, System Center и гибридному облаку</title><link>https://bubnovd.github.io/blogger/%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B-%D0%BF%D0%BE-windows-server-2012r2-system-center-%D0%B8-%D0%B3%D0%B8%D0%B1%D1%80%D0%B8%D0%B4%D0%BD%D0%BE%D0%BC%D1%83-%D0%BE%D0%B1%D0%BB%D0%B0%D0%BA%D1%83/</link><pubDate>Fri, 29 Aug 2014 02:20:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B-%D0%BF%D0%BE-windows-server-2012r2-system-center-%D0%B8-%D0%B3%D0%B8%D0%B1%D1%80%D0%B8%D0%B4%D0%BD%D0%BE%D0%BC%D1%83-%D0%BE%D0%B1%D0%BB%D0%B0%D0%BA%D1%83/</guid><description>Просто пара ссылок.Дайджест материалов по System Center и гибридному облакуДайджест материалов по Windows Server 2012/R2 </description><content>&lt;p>Просто пара ссылок.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Дайджест материалов по System Center и гибридному облаку&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->Дайджест материалов по Windows Server 2012/R2&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>Автоопределение прокси в домене Windows</title><link>https://bubnovd.github.io/blogger/%D0%B0%D0%B2%D1%82%D0%BE%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D0%B2-%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B5-windows/</link><pubDate>Fri, 13 Sep 2013 04:39:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/%D0%B0%D0%B2%D1%82%D0%BE%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D0%B2-%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B5-windows/</guid><description>Автоматизация - дело хорошее. И автоматизирование всего и вся поможет улучшить жизнь системного администратора если не в текущий момент, то в обозримом будущем точно. Для этого решил я настроить автоконфигурирование настроек прокси-сервера на клиентских машинах.
Имеется апдейт!
Как прокси мы используем Usergate (будь он неладен. На человеческие прокси пока не могу уломать начальство). В нем есть свой DHCP сервер с нужной нам функцией. Но в качестве DHCP мы используем стандартные средства Windows Server, поэтому простой вариант с одной галочкой нам не подходит.</description><content>&lt;p>Автоматизация - дело хорошее. И автоматизирование всего и вся поможет улучшить жизнь системного администратора если не в текущий момент, то в обозримом будущем точно. Для этого решил я настроить автоконфигурирование настроек прокси-сервера на клиентских машинах.&lt;br>
Имеется апдейт!&lt;/p>
&lt;p>Как прокси мы используем Usergate (будь он неладен. На человеческие прокси пока не могу уломать начальство). В нем есть свой DHCP сервер с нужной нам функцией. Но в качестве DHCP мы используем стандартные средства Windows Server, поэтому простой вариант с одной галочкой нам не подходит.&lt;br>
 Тут нам на помощь приходит протокол автонастройки прокси (&lt;a href="https://en.wikipedia.org/wiki/Web_Proxy_Autodiscovery_Protocol">WPAD&lt;/a>). Смысл его работы в следующем:&lt;/p>
&lt;ol>
&lt;li>Клиент ищет в сети сервер с именем wpad.domain.local (domain.local тут - имя нашего домена), если такой сервер не находится клиент идет выше - wpad.local (в этом кстати заключается брешь этого протокола, о которой говорили на одной из blackhat-конференций).&lt;/li>
&lt;li>Если сервер найден, клиент пытается прочитать файл wpad.dat, лежащий в корневом каталоге.&lt;/li>
&lt;li>Из этого файла берутся настройки, исходя из которых клиент понимает, в каких случаях нужно идти в сеть через прокси, а в каких напрямую.&lt;/li>
&lt;/ol>
&lt;p>Пример простейшего файла wpad.dat:&lt;/p>
&lt;pre tabindex="0">&lt;code>function FindProxyForURL(url, host)
{
    return &amp;#34;PROXY 192.168.0.254:3128&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>Здесь мы видим, что в качестве адреса прокси-сервера клиенты получают &lt;code>192.168.0.254:3128&lt;/code>. Настройки можно кастомизировать, у файла может быть огромное количество опций. Их вы можете найти в &lt;a href="http://www.google.ru/search?q=wpad+example">поисковике&lt;/a>.&lt;/p>
&lt;p>Итак, будем считать, что файл настроек создан. Нужно положить его в корневую директорию веб-сервера и настроить сам веб-сервер, чтобы он умел отдавать этот файл. У нас используется Apache под виндой, поэтому привожу его конфигурацию: в httpd.conf в секции &lt;code>&amp;lt;IfModule mime\_module&amp;gt;&lt;/code> нужно добавить строку &lt;code>AddType application/x-ns-proxy-autoconfig .dat&lt;/code>&lt;/p>
&lt;p>Следующий этап - настройка DNS-сервера. Нужно внести запись типа CNAME в зону прямого просмотра, указывающую, что под именем &lt;code>wpad.domain.local&lt;/code> будет пониматься ваш веб-сервер. На этом натыкаемся на проблему - винда не разрешает использовать имя wpad. Об этом вам ничего не скажет, но найти сервер по имени wpad в сети вы не сможете. Нужно выполнить в командной строке &lt;code>dnscmd /config /enableglobalqueryblocklist 0&lt;/code> (подробнее &lt;a href="http://technet.microsoft.com/ru-ru/library/cc441517.aspx">здесь&lt;/a>).&lt;/p>
&lt;p>Очищаем кэш ДНС или просто идем курить пить кофе. Выставляем в браузере автонастройку прокси-сервера и получаем счастье. Теперь, если изменится адрес или порт прокси, или просто добавится сервер, на который нужно ходить в обход прокси, то настройки делаются в одном месте, а до клиентов доходят сами.&lt;/p>
&lt;p>Спасибо &lt;a href="http://it-blojek.ru/19/">ит-бложику&lt;/a> за наводку.&lt;/p>
&lt;p>UPD 24.12.2013&lt;br>
Описание параметров в файле wpad.dat производится на языке JavaScript, т.е. можно построить довольно сложную конфигурацию. Вот пример моего файла, проверяющего соответствие IP-адресов и закомментированными сообщениями для дебага (строки, начинающиеся с var и ниже проверяют, находится ли адрес в диапазоне 192.168.100.65 - 192.168.100.240):&lt;/p>
&lt;pre tabindex="0">&lt;code>function FindProxyForURL(url, host)
{
// If specific URL needs to bypass proxy, send traffic direct.
if (shExpMatch(host,&amp;#34;\*subd.domain.local\*&amp;#34;) ||
shExpMatch(host,&amp;#34;\*subd.domain1.local\*&amp;#34;) ||
shExpMatch(host,&amp;#34;192.168.\*&amp;#34;) ||
shExpMatch(host,&amp;#34;127.\*&amp;#34;) ||
dnsDomainIs(host,&amp;#34;.subd.domain.local&amp;#34;) ||
dnsDomainIs(host,&amp;#34;.subd.domain1.local&amp;#34;) ||
isPlainHostName(host))
return &amp;#34;DIRECT&amp;#34;;
// All other traffic uses below proxies, in fail-over order.
//debug=&amp;#34;host=&amp;#34; + host + &amp;#34;\\n&amp;#34; + &amp;#34;url=&amp;#34; + url + &amp;#34;\\n&amp;#34; + &amp;#34;MyIP=&amp;#34; + myIpAddress() +  &amp;#34;\\n&amp;#34;;
var myip = myIpAddress();  // Set a variable for the local IP address.
var myAddrArray = myip.split(&amp;#34;.&amp;#34;);  // Split that IP address var into an array.
var mysubnet3=parseInt(myAddrArray\[2\]);  // Convert array element #2 into a number and store it in a new variable
var mysubnet4=parseInt(myAddrArray\[3\]);
//debug += &amp;#34;Subnet=&amp;#34; + mysubnet3 + &amp;#34;.&amp;#34; + mysubnet4 + &amp;#34;\\n&amp;#34;;
if ((mysubnet3 == 100) &amp;amp;&amp;amp; (mysubnet4 &amp;gt;=65) &amp;amp;&amp;amp; (mysubnet4 &amp;lt;= 240)) {
return &amp;#34;PROXY 192.168.100.14:8080&amp;#34;;}
else {
return &amp;#34;DIRECT&amp;#34;;}
}
&lt;/code>&lt;/pre>&lt;p>В качестве веб-сервера для этой системы очень удобно использовать &lt;code>tinyhttpd&lt;/code>, если нет уже работающих серверов. tynihttpd очень маленький и удобный, не нужно делать ничего лишнего - только &lt;code>index.html&lt;/code>, &lt;code>wpad.dat&lt;/code> и запустить экзешник из cmd.&lt;br>
Ещё DNS сервер Windows не дает разрешить доменные имена wpad и isatap, поэтому с ним нужно поколдовать: в командной строке пишем &lt;code>dnscmd /config /globalqueryblocklist&lt;/code> и будет счастье.&lt;/p>
&lt;p>&lt;code>**UPD 01.09.2014**&lt;/code>&lt;br>
&lt;code>**[Здесь](https://securelist.ru/analysis/obzor/242/pac-fajl-avtokonfiguratsii-problem/) интересная статейка по этой теме.**&lt;/code>&lt;br>
&lt;code>**UPD 08.08.2016**&lt;/code>&lt;br>
&lt;strong>&lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/pbp-final-with-update.pdf">О безопасности при использовании WPAD&lt;/a>&lt;/strong>&lt;/p></content></item><item><title>Небольшой FAQ по настройке печати в RDP</title><link>https://bubnovd.github.io/blogger/%D0%BD%D0%B5%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B9-faq-%D0%BF%D0%BE-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B5-%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B8-%D0%B2-rdp/</link><pubDate>Tue, 31 May 2011 06:46:00 +0000</pubDate><guid>https://bubnovd.github.io/blogger/%D0%BD%D0%B5%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B9-faq-%D0%BF%D0%BE-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B5-%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B8-%D0%B2-rdp/</guid><description>При работе в терминальной сессии принтеры, которые мапятся на серв очень часто капризничают. Очень долго ковырял с чем это может быть связано. В итоге к конкретному решению так и не пришел, но всё, что узнал решил описать здесь.
Вообще сам протокол RDP довольно глючный, поэтому если у кого-то работает принтер в рдп, это ещё не значит, что у Вас на том же железе, с той же конфигурацией всё будет работать без проблем.</description><content>&lt;p>При работе в терминальной сессии принтеры, которые мапятся на серв очень часто капризничают. Очень долго ковырял с чем это может быть связано. В итоге к конкретному решению так и не пришел, но всё, что узнал решил описать здесь.&lt;/p>
&lt;p>Вообще сам протокол RDP довольно глючный, поэтому если у кого-то работает принтер в рдп, это ещё не значит, что у Вас на том же железе, с той же конфигурацией всё будет работать без проблем. Да и у того, у кого работает может через час отвалиться, а замапить принтер получится только с помощью плясок.&lt;/p>
&lt;p>По RDP могут корректно работать только те принтеры, в названии которых присутствуют 3 заветные буковки: PCL. Соответственно драйвера на них нужны тоже PCL. Существует как минимум 2 разновидности этих драйверов: PCL5 и PCL6. Говорят, 6-я версия глючная, поэтому ставить нужно 5-ую. Также существует разница в версиях RDP. Маппинг принтеров поддерживается только в версиях RDP начиная с 5.2 (Windows Server 2003), в версию 6.1 (Windows Server 2008) входит Terminal Services Easy Print driver (позволяет не устанавливать драйвера клиентских принтеров на сервере).  Но это тоже глючная херня и полагаться на неё не стОит.&lt;/p>
&lt;p>Принтеры, подключенные локально к порту, имя которого начинается не с букв COM, LPT или USB печатать так просто не захотят (&lt;a href="http://support.microsoft.com/kb/302361">http://support.microsoft.com/kb/302361&lt;/a>). &lt;/p>
&lt;p>Ещё один костыль для исправления этой проблемы:&lt;br>
1. Устанавливаем локальный USB принтер у клиента стандартным образом;&lt;br>
2. Расшариваем его;&lt;br>
3. даём команду:&lt;br>
net use lpt1: \\имя_компа\имя_принтера /PERSISTENT:YES&lt;br>
4. Устанавливаем новый &amp;ldquo;виртуальный&amp;rdquo; принтер, якобы подключенный к lpt1 и назначаем его по-умолчанию;&lt;br>
5. Всё, после этой операции любой USB принтер, вне зависимости от заявленной производителем совместимости, замечательно видится при подключении к терминалу. (&lt;a href="http://forum.windowsfaq.ru/showthread.php?t=97478">http://forum.windowsfaq.ru/showthread.php?t=97478&lt;/a>)&lt;/p>
&lt;p>Естественно, должна стоять галочка &amp;ldquo;использовать локальные принтеры&amp;rdquo; на клиенте и снята галочка &amp;ldquo;запретить перенаправление принтеров&amp;rdquo; на сервере. Имя принтера должно в точности (вплоть до регистра) совпадать с именем его драйвера на сервере. &lt;/p>
&lt;p>Ещё можно попробовать установить следующие пакеты:&lt;/p>
&lt;p>1. MicrosoftFixit50180&lt;/p>
&lt;p>2. WindowsXP-KB972422-x86-RUS&lt;/p>
&lt;p>А ещё лучше использовать пакет ScrewDrivers и подобные, но это довольно дорого.&lt;br>
Насчет ScrewDrivers вот что мне ответили на одном известном форуме: &amp;ldquo;Дорого, потому что нет лучшего решения. Всё что ты выше написал - мура, проверенная многолетней еблей с печатью. &amp;quot; Так что решайтесь =)&lt;/p>
&lt;p>Информация отсюда:&lt;br>
1. &lt;a href="http://ru.wikipedia.org/wiki/Remote_Desktop_Protocol">http://ru.wikipedia.org/wiki/Remote_Desktop_Protocol&lt;/a>&lt;br>
2. &lt;a href="http://www.gotdotnet.ru/blogs/blackhawk/1243/">http://www.gotdotnet.ru/blogs/blackhawk/1243/&lt;/a>&lt;br>
3. &lt;a href="http://www.tonk.ru/support/faq/printers02/">http://www.tonk.ru/support/faq/printers02/&lt;/a>&lt;br>
4. &lt;a href="http://www.tonk.ru/support/faq/printers01/">http://www.tonk.ru/support/faq/printers01/&lt;/a> &lt;/p>
&lt;p>    &lt;a href="http://www.osp.ru/win2000/2001/02/174688/">http://www.osp.ru/win2000/2001/02/174688/&lt;/a>&lt;/p>
&lt;p>UPD:&lt;br>
Большинство принтеров будут корректно работать в терминальной сессии, если разрядность операционных систем сервера и клиента совпадает. То есть если на серве Windows 2008R2 (а она выпускается только в 64-разрядной редакции), а на клиенте - Win XP 32, то 90%, что принтер в терминале печатать не будет. А если на клиенте Windows 7 x64 - 90%, что проблем не будет.&lt;br>
 Возможно, ещё играет роль семейство ОС (т.е. Win7 не будет печатать на WinServ2003 и наоборот). Хотя это лишь догадки - не проверял. Если кто знает - добро пожаловать в комменты!&lt;br>
Если клиент не в локальной сети, а в интернете - поднимайте VPN.&lt;br>
Ещё можно почитать &lt;a href="http://sysadmins.ru/post8112079.html">здесь&lt;/a>.&lt;/p></content></item></channel></rss>