+++
title = "Memory"
date = "2022-09-11T11:52:28Z"
author = ""
authorTwitter = "bubnovdnet"
cover = "/img/vm/Linux_logo.jpg"
tags = ["OS", "Linux", "Memory"]
keywords = ["OS", "Linux", "Memory", "OSTEP"]
description = "Виртуальная память в Linux"
showFullContent = false
readingTime = true
hideComments = false
+++

Большинство из нас пользуется 64-разрядными системами. В таких системах процессы работают с адресным пространством размером 2^64 байт (16 эксабайт или 16 млн ТБ). Многие из читателей имеют столько памяти в системе? Как получается, что процесс видит 16 ЭБ памяти, когда в системе её намного меньше? Как получается, что относительно небольшая физическая память так интенсивно используется программами и не позволяет читать чужие данные? Как распределяется между процессами физическая память?

На эти вопросы отвечает книга `Operating Systems. Three easy pieces`. До её прочтения я слабо представлял себе работу ОС. А теперь представляю ещё хуже, зато более системно =) Вы ведь знакомы с этим чувством, когда начинаешь изучать что-то новое и открываешь новую пропасть в своих знаниях, которую придется заполнять ещё долгие годы?

Во время чтения книги появилась идея написать серию постов о работе ОС. Хочу начать с виртуальной памяти, так как мне её работа показалась очень элегантной и эффективной.

## Итак, виртуальная память в Linux

Чем хороша виртуализация памяти: прозрачность, эффективность, изоляция
- Прозрачность (transparency ). Virtual memory реализована операционной системой абсолютно незаметно для процессов. Программы не знают что там происходит с памятью. Они думают, что владеют всей памятью в системе и не заботятся об изоляции от дургих проессов

- Эффективность (efficiency). Программисту не нужно думать о том, как и где хранить переменные, потому что виртуальное адресное пространство огромно. Жизнь становится проще, если не нужно задумываться о работе с низкоуровненвыми абстракциями. ОС делает виртуализацию максимально эффективной по времени и размеру. Благодаря работе с железом ОС делает этот процесс ещё лучше (MMU, TLB)

- Изоляция. ОС обеспечивает изоляцию адресных пространств. Один процесс не может обратиться к памяти другого. Спцеиально или из-за бага

---

- Процесс Петя имеет счет в банке PM и приложение VM, которое показывает количество денег


Давным давно системы были однозадачными и вся память была доступна одному процессу. Не надо было беспокоиться о приватности данных и безопасности. Потом наступила эра многозадачности: компьютером стали пользоваться одновоременно несколько человек. Каждый запускает свои программы. Ранние реализации просто отдавали всю память процессу, а когда приходил другой процесс - содержимое памяти первого сбрасывалось на диск и в неё загружались данные нового процесса.
Очевидно, что запись и чтение с диска - операция затратная и куча времени бесполезно расходовалась на это. Нужен был новый, более эффективный процесс.

Этот процесс назвали Sharing, Virtualization - посмореть в комментах на хабре как называется
![sharing-memory-3-processes](/img/vm/sharing-memory-3-processes.png)
!Посмотреть как строить схемы в описании темы или хуго


- адрес спейс - это то, что видит прорамма. Абстракция
Сам адрес спейс делится на три чсти
The heap thus starts just after the code (at 1KB) and grows
downward (say when a user requests more memory via malloc()); the
stack starts at 16KB and grows upward (say when a user makes a proce-
dure call).
![тут картинка адрес спейса]()

адрес пейс - всего лишь абстракция. Это не значит, что программа занимает фиизическую память с 0 до 256 байт. Если взглянуть на sharing-memory-3-processes, то станет ясно, что с памятью одновременно работают несколько процессов, каждый из которых имеет свой адрес сейс, начинающийся с нуля

Как ОС создаёт эту иллюзию приватной огромной адресного пространства на единой, не всегда большой физической памяти?


Это и есть виртуализайия
!изляция



Goals:
- Прозрачность (transparency ). Virtual memory реализована операционной системой абсолютно незаметно для процессов. Программы не знают что там происходит с памятью. Они думают, что владеют всей памятью в системе и не заботятся об изоляции от дургих проессов.
- Эффективность (efficiency). ОС делает виртуализацию максимально эффективной во времени и размере. Благодарся работе с жезеом, ОС может сделать этот процесс наиболееэффектиным (MMU, TLB)
- Защита. ОС обеспечивает изоляцию адресных пространств. Один процесс не может обратиться к памяти другого.
---
Дальше моё сочинительство


Каждый процесс считает, что ему доступно 2^32 (4096 МБ) или 2^64 (16 млн ТБ) байт памяти. Но как это возможно, если в системе памяти значительно меньше?
Наверняка многие слышали о понятии "виртуальная ппамять". Эта фича ОС и позволяет обманывать процессы, предлагая им для испоьзования столько памяти, сколкьо в систее просто нет.

Попробуем разобраться как это работает.
Адресное простарнство - вся память, доступная проессу. Для простоты будем рассматривать 8-битную систему. Адресное пространство в ней будет равно 2^8 = 256 байт. 
Процесс использует для работы три элемента (три счета): 
!Описать каждый
- код. Статичен. Всегда занимает одинаковое кол-во памяти. Можно шарить между процесаами?
- стэк
- куча

Заранее никто не может знать сколько памяти нужно стеку или хипу. Поэтому для них выделяется какая-то инициализационная часть памяти с возможностью расширения. Чтобы не мешать друг другу они занимают адресное пространство с противополоных сторон и растут в разные стороны. Стек растет вверх (от большего к меньшему: 256 -> 100), хип растет вниз (от меньшего к большему: 10 -> 50)
```
  -------------- 0
  |    Code    |
  -------------- 10
  |    Heap    |
  |     |      |
  |     v      |
  -------------- 50
  |   (free)   |
  |     ...    |
  -------------- 100
  |     ^      |
  |     |      |
  |   Stack    |
  -------------- 256
```

Получается, что в 64-разрядной системе каждый процесс считает, что ему доступно 16 экзабаййт памяти. Сколько раз вы видели компьютер с таким количеством оперативы? Вот и в нашей восьмибитной системе нет 256 байт памяти, а есть только 100







# Interlude: Memory API

вставить здесь спойлер
- почитать про malloc()
- почитать про sizeof()
- почитать про free()
- это не сисколы, а лайбраари колы
- почиттаь про brk(), sbrk - change the location of the program’s break: the location of the end of the heap. Они не могут использоваться напрямую. Они ывзываются через malloc и free
- почитать про mmap()

# Mechanism: Address Translation
Виртуализация памяти обеспечивается ОС вкупе с железной поддержкой
Трансляция адресов: преобразование виртуального адреса в физический

Тут приводятся упрощения, что адресное пространство размещено в памяти последовательно (смежно), адресное пространство меньше физичексой памяти и все адресные пространства одного размера

base and bound registers - HW Relocation. MMU

Example:
Address Space Size 4 KB
Loaded in phys address 16 KB
• Virtual Address 0 → Physical Address 16 KB
• VA 1 KB → PA 17 KB
• VA 3000 → PA 19384
• VA 4400 → Fault (out of bounds)

Проблемы:
- При создании процесса ОС должна найти место в физ памяти для размещения там адресного пространства процесса. То есть нужно иметь список свободного места (free list)
- После завершения процесса нужно освободить его место в физ памяти  и записать обратно в free list
- У ЦПУ только одна пара бэйз-баунд регистров. При конекст свитчинге нужно сохранить куда-то бэйз и баунд текущего процесса и считать откуда-то эти регистры нового процесса. Procss Control Block (PCB)

Доступ к регистрам привилигрованный. Только кернел моде может к ним ходить. Если бы это мог делать обычный процесс, он бы мог перезаписать значения регистров и пойти в чужую память

- Мы смогли создать независимую память для каждого процесса и изолировать её. Но т.к. аллоцируем всё адресное пространство, то аллоцируемое, но неиспользуемое место между хипом и стеком простаивает впустую. Это называется внутренней фрагментацией

# Segmetation

Для предовтарщения внтрннеей фрагментации можно вместо одной пары регистров использовать три: код, стек, хип
![placing-segments-in-physical-memory.png](/img/vm/placing-segments-in-physical-memory.png)

```
  -------------- 0 KB
  |  Operating |
  |   System   |
  -------------- 16 KB
  | not in use |
  |            |
  --------------
  |     ^      |
  |     |      |
  |   Stack    |
  --------------
  | not in use |
  |            |
  -------------- 32 KB
  |    Code    |
  --------------
  |    Heap    |
  |     |      |
  |     V      |
  -------------- 
  |            |
  |            |
  |    not     |
  |     in     |
  |    use     |
  |            |
  |            |
  |            |
  -------------- 64 KB
```


Получаем ткую структурру в ММУ

Segment | Base | Size
--------|------|-------
Code    | 32K   | 2K
Heap    | 34K   | 2K
Stack   | 28K   | 2K

Обратимся к адресу 100 в этой таблице. Добавляем сдвиг 100 к Base. Получаем 32К + 100 = 32768 + 100 = 32868. Этот адрес входит в предел 32К + 2К. Это КОД

![an-address-space.png](/img/vm/an-address-space.png)

Попробуем обратиться к адресу 4200, который должен быть в хипе. 34К + 4200 = 34816 + 4200 = 39016. 39016 > 36864. Полученный адрес не входит в сегмента хипа.  Но так как это новый сегмент (не код). Нужно получить сдвиг (offset). Так как хип начинается с 4 КБ (в соответствии с ![an-address-space.png]) и нам нужен адрес 4200, то офсет будет 4200-4096=104. Получаем 34816 + 104 = 34920
Получли Segmentation Fault - обрщение к памяти за пределелами нашего адресного пространства

Но как обратиться к стеку? Ведь он растет в обратном направлении? Сначала посчитаем наше место в адресном пространстве. При обращении к виртуальному адрсу 15K. Он мапится на физический адрес 27 КБ. 15 КБ = 11 1100 0000 0000 . Старшие два бита определяют сегмент, значит на смещение остается 3 КБ (РАСПИСАТЬ ТУТ КАК ЭТО ПОЛУЧАЕТСЯ). Чтобы получить корректный отрицательный сдвиг, надо вычесть из него максимальный размер сегмента (откуда он берется? Посмотреть в домашке) 3 КБ. Получаем  3 - 4 = -1. Добавляем полученный результат к base 28 - 1 = 27 КБ


Иногда требуется шарить некоторые сегменты между адрес спейсами. Например шаринг сегмента с кодом. Для шжринга используется protection bit. Выставив его в read-only мы озволим читать из сегмента дргуим процессам

Итак, сегментация позволилиа нам не расходовать впустую огромные куски памяти с минимальным оверхедом на трансляцию/
 проблема заключается в том, что сегментация все еще недостаточно гибкая, чтобы поддерживать наше полностью обобщенное, разреженное адресное пространства. Например, если у нас есть большая, но редко используемая куча, расположенная в одном логическом сегменте, вся куча все равно должна находиться в памяти, чтобы к ней можно было получить доступ доступ к ней. Другими словами, если наша модель использования адресного пространства не совсем соответствует тому, как базовая сегментация была то сегментация работает не очень хорошо. Таким образом, нам необходимо найти новые решения


# Free-Space Management